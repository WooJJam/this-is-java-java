# 📌 Chapter6 클래스

## 1. 객체
- 물리적으로 존재하거나 개념적인 것 중에서 다른 것과 식별 가능한 것
- EX) 자동차를 설계하고자 할때 부품들이 객체가 됨 (창문, 타이어, 문..)
- `속성(Field)`과 `동작(Method)`으로 구분
  
    => 이러한 객체들을 하나씩 조립하여 완성된 프로그램을 개발하는 것을 **`객체지향 프로그래밍`** 이라고 함 

## 2. 객체지향 프로그맹의 특징

### 1. 캡슐화
+ 데이터(필드), 동작(메소드)를 하나로 묶고 실제 구현 내용을 외부로부터 감추는 것
+ 외부의 잘못된 사용으로 인해 객체가 손상되지 않도록 함

    => **접근 제한자** 사용

### 2. 상속
> 실무에서는 상속의 사용을 최대한 피해야 한다. 
> 자바의 창시자인 "**내가 자바를 만들면서 가장 후회하는 일은 상속을 만든 점이다**"라고 언급할 정도.. [참고 자료](https://inpa.tistory.com/entry/OOP-%F0%9F%92%A0-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5%EC%9D%98-%EC%83%81%EC%86%8D-%EB%AC%B8%EC%A0%9C%EC%A0%90%EA%B3%BC-%ED%95%A9%EC%84%B1Composition-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0)

+ 부모 객체가 가지고 있는 필드와 메소드를 자식 객체에게 물려주어 자식 객체가 사용할 수 있도록 하는 것
    #### 장점
    - 코드의 재사용성이 높아짐
      + 부모 객체의 필드와 메소드를 자식이 그대로 사용할 수 있으므로 중복 코딩을 피할 수 있음
    - 유지 보수 시간을 최소화
      + 부모 객체의 필드와 메소드를 수정하면 모든 자식 객체들은 수정된 필드와 메소드 사용 가능    
  
### 3. 다형성
- 사용 방법은 동일하지만 실행 결과가 다양하게 나오는 성질

    -> 상속, 인터페이스에서 자세하게 이해하고 넘어가자

### 4. 추상화 
- 원래 자바의 특징 4가지중 1개이지만 해당 챕터에서는 추상화에 대한 설명을 하지 않고 있음 (아마 인터페이스에서 설명하지 않을까 싶음)

## 3. 클래스 선언
- Car.java
```
public class Car {...}

class Tier() {...}
```
- Public 클래스는 파일당 1개만 생성 가능 (그러므로 파일당 클래스는 한개가 좋겠죠?)

## 4. 객체 생성과 클래스 변수
- 클래스 변수가 객체를 참조하는 방식
  
![Untitled](https://github.com/user-attachments/assets/6108361a-cf0d-40da-aebd-f820086d9a2f)

```
객체 생성은 new() 키워드
클래스 변수 = new 클래스();

Person p1 = new Person();
Person p2 = new Person();
-> 클래스 변수를 생성시 메모르 스택 영역에서 다음과 같이 객체를 참조함
-> 만약 new() 키워드로 변수를 계속 생성한다면? 메모리에 쌓이게 됨 -> 싱글톤 패턴!
```

## 5. 생성자 오버로딩 (Overloading)
- 매개 변수를 달리하는 생성자를 여러개 선언한 것
- 매개변수의 타입과 개수 모두 같으면 안됨
```
public Class Car {
	
	Car() {...}
	Car(String model) {...}
	Car(String model, String color) {...}
	Car(int count, String color) {...}
}

Quiz) 이것도 생성자 오버로딩으로 볼 수 있을까?

Car(String model, String color) {...}
Car(String color, String model) {...}
```

## 6. 가변길이 매개변수
- 매개변수로 들어오는 값의 개수와 상관없이 동적으로 인수를 받아 처리 가능하도록 해주는 문법
```
String sum(int a)
String sum(int a, int b)
String sum(int a, int b, int c)
...
이렇게 매개변수의 수가 사용자의 쓰임에 따라 늘어난다면 어떡할까?
하나하나 다 선언할 것 인가? => 당연히 아니겠지

void sum(int...num) { => 가변 매개 변수를 사용
        for(int a:num)
            result += a;
} 
```

## 7. 메소드 오버로딩
- 메소드 이름은 같되 매개 변수의 타입, 개수, 순서가 다른 메소드를 여러개 선언하는 것
```
class 클래스 {
	리턴 타입 메소드 이름 (타입 변수, ...) {...}
}                           ㄴ> 여기만 다름
```
```
public class Calculator {
	
	double getAreaRectangle(double width) { //정사각형 넓이
		return width * width;
	}
	
	double getAreaRectangle(double width, double height) { // 직사각형 넓이
		return width * height
	}
	
}
```

## 8. 인스턴스 멤버 VS 정적 멤버
### 1. 인스턴스 멤버
- 객체에 소속된 멤버, 객체를 생성해야만 사용할 수 있는 멤버 (지금까지 예제는 모두 인스턴스 멤버)
        
  - 필드의 경우 객체 소속이며 객체 생성시 스택 영역에서 메모리를 차지함
  - 메소드의 경우 객체에 ‘소속’된거지 ‘포함’된건 아니다.
    
    → 메소드 영역에 두어 공유해서 사용하고, 객체 없이는 사용하지 못하도록 제한
            
    
### 2. 정적 멤버
- 클래스에 고정된 멤버, 객체 없이도 사용할 수 있는 멤버
    - 자바는 JVM의 클래스 로더를 통해 런타임 시점에 클래스를 로딩하고 매소드 영역에 클래스를 저장
        
        → 즉) 메소드 영역에 고정적으로 위치하기에 객체 생성 없이 클래스를 통해 바로 사용이 가능함

    ```
    public class 클래스 {
	// 정적 필드 선언
	static 타입 필드 = [초기값];
	
	// 정적 메소드 선언
	static 리턴타입 메소드(매개변수, ...) {...}
    }
    ```

### 3. 인스턴스 필드를 이용하지 않는 메소드는 정적 메소드로 선언하는 것이 좋다.

    public class Calculator {
        String color;
        void setColor(String color) {this.color = color; }
        static int plus(int x, int y) { return x + y; }
        static int minus(int x, int y) { return x - y; }
    }


### 4. 정적 필드는 생성자에서 초기화 할 수 없다.
- 정적 필드와 메소드는 객체 없이 사용할 수 있지만 생성자는 객체 생성 후 실행되기 때문

```
 - 초기화 방법 
   1. 필드 선언과 동시에 초기화 
    static double pi = 3.14159;

   2. 정적 블록 사용 
    static {
        pi = 3.14159;
    }

- 인스턴스 멤버랑은?
   1. 인스턴스 필드나 인스턴스 메소드를 사용할 수 없음
   2. 객체 자신의 참조인 this도 사용 불가
```


## final 필드
- 인스턴스 필드와 정적 필드는 언제든지 값을 변경할 수 있었음
- 하지만 final 필드는 초기값이 저장되면 이것이 최종적인 값이 됨

>**final 필드의 초기화 방법**
>1. 필드 선언 시에 주기
>2. 생성자 초기화

## 상수
- 정적 변수 + final 필드
    - 객체 없이 사용 가능 + 한번 초기화 하면 변경 불가능
    - 객체마다 저장할 필요 X, 여러 개의 값을 가지지 않아도 됨
  
  ``` 
  QUIZ) 초기화 방법은?
   1. 
   2. 
   ```

## 싱글톤 패턴
- 단 하나의 객체만 생성해서 사용
- 핵심!
    - 생성자는 private 접근 제한 → 외부에서 new 연산자로 생성자 호출 금지
    - 정적 메소드를 통해 간접적으로 객체를 얻음
  
```
  public class 클래스 {
	//private 접근 권한을 갖는 정적 필드 선언과 초기화
	private static 클래스 singleton = new 클래스();
	
	//private 접근 권한을 갖는 생성자 선언
	private 클래스() {}
	
	//public 접근 권한을 갖는 정적 메소드 선언
	public static 클래스 getInstance() {
		return singleton;
	}
}
```
